syntax = "proto3";

package he_service;

// Main service for Homomorphic Encryption operations
service HEService {
  // Generate encryption keys for a specific HE library
  rpc GenerateKeys(GenerateKeysRequest) returns (GenerateKeysResponse);
  
  // Encrypt a list of integers
  rpc Encrypt(EncryptRequest) returns (EncryptResponse);
  
  // Decrypt a ciphertext
  rpc Decrypt(DecryptRequest) returns (DecryptResponse);
  
  // Add two encrypted numbers
  rpc Add(BinaryOpRequest) returns (BinaryOpResponse);
  
  // Multiply two encrypted numbers
  rpc Multiply(BinaryOpRequest) returns (BinaryOpResponse);
  
  // Run a benchmark for a single library
  rpc RunBenchmark(BenchmarkRequest) returns (BenchmarkResponse);
  
  // Run comparison benchmark for all three libraries
  rpc RunComparisonBenchmark(BenchmarkRequest) returns (ComparisonBenchmarkResponse);

  // Run encrypted MNIST digit inference (full HE-CNN pipeline)
  rpc PredictDigit(PredictRequest) returns (PredictResponse);
}

// Request to generate keys
message GenerateKeysRequest {
  string library = 1;  // "SEAL", "HELib", or "OpenFHE"
  int32 poly_modulus_degree = 2;  // Security parameter (e.g., 8192)
}

// Response with session ID and public key
message GenerateKeysResponse {
  string session_id = 1;  // Unique session identifier
  bytes public_key = 2;   // Serialized public key
  string status = 3;      // "success" or error message
}

// Request to encrypt data
message EncryptRequest {
  string session_id = 1;      // Session from GenerateKeys
  repeated int64 values = 2;  // Values to encrypt
}

// Response with encrypted data
message EncryptResponse {
  bytes ciphertext = 1;  // Serialized ciphertext
  string status = 2;
}

// Request to decrypt data
message DecryptRequest {
  string session_id = 1;  // Session ID
  bytes ciphertext = 2;   // Ciphertext to decrypt
}

// Response with decrypted data
message DecryptResponse {
  repeated int64 values = 1;  // Decrypted values
  string status = 2;
}

// Request for binary operations (add/multiply)
message BinaryOpRequest {
  string session_id = 1;
  bytes ciphertext1 = 2;
  bytes ciphertext2 = 3;
}

// Response for binary operations
message BinaryOpResponse {
  bytes result_ciphertext = 1;
  string status = 2;
}

// Request to run benchmark
message BenchmarkRequest {
  string library = 1;          // Which library to benchmark: "SEAL", "HELib", "OpenFHE", or "ALL"
  int32 num_operations = 2;    // Number of operations to run
}

// Benchmark results for a single library
message BenchmarkResponse {
  double key_gen_time_ms = 1;
  double encryption_time_ms = 2;
  double addition_time_ms = 3;
  double multiplication_time_ms = 4;
  double decryption_time_ms = 5;
  string status = 6;
  double total_time_ms = 7;           // Total benchmark time
  double encoding_time_ms = 8;        // Time spent encoding data
}

// Comparison benchmark results (all libraries)
message ComparisonBenchmarkResponse {
  BenchmarkResponse seal = 1;
  BenchmarkResponse helib = 2;
  BenchmarkResponse openfhe = 3;
  string fastest_library = 4;         // Which library was fastest overall
  string recommendation = 5;          // Usage recommendation based on results
}

// Request for encrypted MNIST digit prediction
message PredictRequest {
  repeated int64 pixels = 1;          // 784 pixel values (28×28 image, row-major, 0-255 range)
  int64 scale_factor = 2;             // Quantization scale factor (default: 1000)
}

// Response from encrypted MNIST digit prediction
message PredictResponse {
  int32 predicted_digit = 1;          // Predicted digit (0-9), argmax of logits
  repeated int64 logits = 2;          // Raw output logits (10 values, one per digit class)
  double confidence = 3;              // Softmax-like confidence score for the predicted digit
  string status = 4;                  // "success" or error message

  // Per-layer timing breakdown (milliseconds)
  double encryption_ms = 5;           // Encrypt input pixels → ciphertext
  double conv1_ms = 6;               // Conv1: 28×28 → 24×24 (5×5 kernel, ÷scale)
  double bias1_ms = 7;               // Add Conv1 bias
  double act1_ms = 8;                // Square activation x²/scale after Conv1
  double pool1_ms = 9;               // AvgPool 2×2 (24×24 → 12×12)
  double conv2_ms = 10;              // Conv2: 12×12 → 8×8 (5×5 kernel, ÷scale)
  double bias2_ms = 11;              // Add Conv2 bias
  double act2_ms = 12;               // Square activation x²/scale after Conv2
  double pool2_ms = 13;              // AvgPool 2×2 (8×8 → 4×4)
  double fc_ms = 14;                 // FC matmul: 16 → 10 (÷scale)
  double bias_fc_ms = 15;            // Add FC bias
  double decryption_ms = 16;         // Decrypt output → plaintext logits
  double total_ms = 17;              // Total wall-clock time (encrypt → decrypt)

  // Model metadata
  double float_model_accuracy = 18;  // Float model accuracy from training (e.g., 97.5)
}
